.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "EPERL 1"
.TH EPERL 1 "2008-12-23" "eperl.pod" ""
.SH "NAME"
ePerl \- Embedded Perl 5 Language
.SH "VERSION"
.IX Header "VERSION"
@V@
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBeperl\fR
[\fB\-d\fR \fIname\fR=\fIvalue\fR]
[\fB\-D\fR \fIname\fR=\fIvalue\fR]
[\fB\-I\fR \fIdirectory\fR]
[\fB\-B\fR \fIbegin_delimiter\fR]
[\fB\-E\fR \fIend_delimiter\fR]
[\fB\-i\fR]
[\fB\-k\fR]
[\fB\-P\fR]
[\fB\-C\fR]
[\fB\-L\fR]
[\fB\-T\fR]
[\fB\-w\fR]
[\fB\-x\fR]
[\fB\-m\fR \fImode\fR]
[\fB\-o\fR \fIoutputfile\fR]
[\fB\-c\fR]
[\fB\-X\fR]
[\fB\-e\fR]
[\fB\-s\fR]
[\fB\-t\fR]
[\fB\-1\fR]
[\fIinputfile\fR]
.PP
\&\fBeperl\fR
[\fB\-r\fR]
[\fB\-l\fR]
[\fB\-v\fR]
[\fB\-V\fR]
[\fB\-h\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Abstract"
.IX Subsection "Abstract"
ePerl interprets an \s-1ASCII\s0 file bristled with Perl 5 program statements by
evaluating the Perl 5 code while passing through the plain \s-1ASCII\s0 data. It can
operate in various ways: As a stand-alone Unix filter or integrated Perl 5
module for general file generation tasks and as a powerful Webserver scripting
language for dynamic \s-1HTML\s0 page programming.
.PP
ePerl was originally written as a C program by Ralf S. Engelschall.  
It was rewritten in Perl by David Madison.  This document is a 
modification of the original document written by Ralf.  Information 
about both versions can be found at the end of this document.
.Sh "Introduction"
.IX Subsection "Introduction"
The \fBeperl\fR program is the \fIEmbedded Perl 5 Language\fR interpreter.  
It is designed for general \s-1ASCII\s0 file generation with the philosophy 
of \fIembedding\fR the Perl 5 program code into the \s-1ASCII\s0 data instead 
of the usual way where you embed the \s-1ASCII\s0 data into a Perl 5 program 
(usually by quoting the data and using them via \f(CW\*(C`print\*(C'\fR statements). 
So, instead of writing a plain Perl script like
.PP
.Vb 6
\&  #!/path/to/perl
\&  print "foo bar\en";
\&  print "baz quux\en";
\&  for ($i = 0; $i < 10; $i++) { print "foo #${i}\en"; }
\&  print "foo bar\en";
\&  print "baz quux\en";
.Ve
.PP
you can write it now as an ePerl script:
.PP
.Vb 6
\&  #!/path/to/eperl
\&  foo bar
\&  baz quux
\&  <: for ($i = 0; $i < 10; $i++) { print "foo #${i}\en"; } :>
\&  foo bar
\&  baz quux
.Ve
.PP
Although the ePerl variant has a different source file layout, the semantic is
the same, i.e. both scripts create exactly the same resulting data on
\&\f(CW\*(C`STDOUT\*(C'\fR.
.Sh "Intention"
.IX Subsection "Intention"
ePerl is simply a glue code which combines the programming power of the Perl 5
interpreter library with a tricky embedding technique.  The embedding trick is
this: it converts the source file into a valid Perl script which then gets
\&\fIentirely\fR evaluated by only one instance of the Perl 5 interpreter.
To achieve this, ePerl translates all plain code into (escaped) Perl 5 strings
placed into \fIprint\fR constructs while passing through all embedded native Perl
5 code. As you can see, ePerl itself does exactly the same internally that a
silly programmer had to do when writing a plain Perl generation script. 
.PP
Due to the nature of such bristled code, ePerl is really the better attempt
when the generated \s-1ASCII\s0 data contains really more static as dynamic data. Or
in other words: \fIUse ePerl if you want to keep the most of the generated \s-1ASCII\s0
data in plain format while just programming some bristled stuff.\fR Do not use it
when generating pure dynamic data. There it brings no advantage to the
ordinary program code of a plain Perl script. So, the static part should be at
least 60% or the advantage becomes a disadvantage.
.PP
ePerl in its origin was actually designed for an extreme situation: as a
webserver scripting-language for on-the-fly \s-1HTML\s0 page generation. Here you
have the typical case that usually 90% of the data consists of pure static
\&\s-1HTML\s0 tags and plain \s-1ASCII\s0 while just the remaining 10% are programming
constructs which dynamically generate more markup code. This is the reason why
ePerl beside its standard Unix filtering runtime-mode also supports the
\&\s-1CGI/1\s0.1 and \s-1NPH\-CGI/1\s0.1 interfaces.
.Sh "Embedded Perl Syntax"
.IX Subsection "Embedded Perl Syntax"
Practically you can put any valid Perl constructs inside the ePerl blocks the
used Perl 5 interpreter library can evaluate. But there are some important
points you should always remember and never forget when using ePerl:
.IP "\fI1. Delimiters are always discarded.\fR" 4
.IX Item "1. Delimiters are always discarded."
Trivially to say, but should be mentioned at least once. The ePerl block
delimiters are always discarded and are only necessary for ePerl to recognize
the embedded Perl constructs. They are never passed to the final output.
.ie n .IP "\fI2. Generated content has to go to \fI""STDOUT""\fI.\fR" 4
.el .IP "\fI2. Generated content has to go to \f(CISTDOUT\fI.\fR" 4
.IX Item "2. Generated content has to go to STDOUT."
Although you can define subroutines, calculate some data, etc.  inside ePerl
blocks only data which is explicitly written to the \f(CW\*(C`STDOUT\*(C'\fR filehandle is
expanded. In other words: When an ePerl block does not generate content on
\&\f(CW\*(C`STDOUT\*(C'\fR, it is entirely replaced by an empty string in the final output.
But when content is generated it is put at the point of the ePerl block in the
final output. Usually contents is generated via pure \f(CW\*(C`print\*(C'\fR constructs which
implicitly use \f(CW\*(C`STDOUT\*(C'\fR when no filehandle is given.
.ie n .IP "\fI3. Generated content on \fI""STDERR""\fI always leads to an error.\fR" 4
.el .IP "\fI3. Generated content on \f(CISTDERR\fI always leads to an error.\fR" 4
.IX Item "3. Generated content on STDERR always leads to an error."
Whenever content is generated on the \f(CW\*(C`STDERR\*(C'\fR filehandle, ePerl displays an
error (including the \s-1STDERR\s0 content). Use this to exit on errors while passing
errors from ePerl blocks to the calling environment.
.Sp
This isn't true in plain filtered, non-debug mode because it is somewhat
inefficient, but you can turn it on by using the \-\-strict flag.
.IP "\fI4. Last semicolon.\fR" 4
.IX Item "4. Last semicolon."
Because of the following point 6 (see below) and the fact that most of the
users don't have the internal ePerl block translations in mind, ePerl is smart
about the last semicolon. Usually every ePerl block has to end with the
semicolon of the last command.
.Sp
.Vb 1
\&   <: cmd; ...; cmd; :>
.Ve
.Sp
But when the last semicolon is missing it is automatically added
by ePerl, i.e. 
.Sp
.Vb 1
\&   <: cmd; ...; cmd :>
.Ve
.Sp
is also correct syntax.  But sometimes it is necessary to force ePerl \fInot\fR
to add the semicolon. Then you can add a ``\f(CW\*(C`_\*(C'\fR'' (underscore) as the last
non-whitespace character in the block to force ePerl to leave the final
semicolon. Use this for constructs like the following
.Sp
.Vb 5
\&   <: if (...) { _:>
\&   foo
\&   <: } else { _:>
\&   bar 
\&   <: } :>
.Ve
.Sp
where you want to spread a Perl directive over more ePerl blocks.
.ie n .IP "\fI5. Shorthand for \fI""print""\fI\-only blocks.\fR" 4
.el .IP "\fI5. Shorthand for \f(CIprint\fI\-only blocks.\fR" 4
.IX Item "5. Shorthand for print-only blocks."
Because most of the time ePerl is used just to interpolate variables, e.g.
.Sp
.Vb 1
\&   <: print $VARIABLE; :>
.Ve
.Sp
it is useful to provide a shortcut for this kind of constructs.  So ePerl
provides a shortcut via the character '='. When it immediately (no whitespaces
allowed here) follows the begin delimiter of an ePerl block a \f(CW\*(C`print\*(C'\fR
statement is implicitly generated, i.e. the above block is equivalent to
.Sp
.Vb 1
\&   <:=$VARIABLE:>
.Ve
.Sp
Notice that the semicolon was also removed here, because it gets automatically
added (see above).
.IP "\fI6. Special EndOfLine discard command for ePerl blocks.\fR" 4
.IX Item "6. Special EndOfLine discard command for ePerl blocks."
ePerl provides a special discard command named ``\f(CW\*(C`//\*(C'\fR'' which discards all
data up-to and including the following newline character when directly
followed an end block delimiter. Usually when you write
.Sp
.Vb 3
\&  foo
\&  <: $x = 1; :>
\&  quux
.Ve
.Sp
the result is
.Sp
.Vb 1
\&  foo
.Ve
.Sp
.Vb 1
\&  quux
.Ve
.Sp
because ePerl always preserves code around ePerl blocks, even
just newlines. But when you write
.Sp
.Vb 3
\&  foo
\&  <: $x = 1; :>//
\&  quux
.Ve
.Sp
the result is 
.Sp
.Vb 2
\&  foo
\&  quux
.Ve
.Sp
because the ``\f(CW\*(C`//\*(C'\fR'' deleted all stuff to the end of the line, \fIincluding\fR
the newline.
.IP "\fI7. Restrictions in parsing.\fR" 4
.IX Item "7. Restrictions in parsing."
ePerl does not try to parse Perl code to see if end delimiters are in
strings or not.  \fBAll instances of end delimiters will end the embedded perl\fR.
In other words, if you want to use an end delimiter in your perl blocks,
you either need to escape them (such as ``\f(CW\*(C`\e<\e:\*(C'\fR'') or change your
delimiters.
.IP "\fI8. \s-1HTML\s0 entity conversion.\fR" 4
.IX Item "8. HTML entity conversion."
Because one of ePerl's usage is as a server-side scripting-language for \s-1HTML\s0
pages, there is a common problem in conjunction with \s-1HTML\s0 editors.  They
cannot know ePerl blocks, so when you enter those blocks inside the editors
they usually encode some characters with the corresponding \s-1HTML\s0 entities. The
problem is that this encoding leads to invalid Perl code. ePerl provides the
option \fB\-C\fR for decoding these entities which is automatically turned on in
\&\s-1CGI\s0 modes. See description below under option \fB\-C\fR for more details.
.Sh "Runtime Modes"
.IX Subsection "Runtime Modes"
ePerl can operate in three different runtime modes:
.IP "\fIStand-alone Unix filter mode\fR" 4
.IX Item "Stand-alone Unix filter mode"
This is the default operation mode when used as a generation tool from the
Unix shell or as a batch-processing tool from within other programs or
scripts:
.Sp
.Vb 4
\&  $ eperl [options] \- < inputfile > outputfile
\&  $ eperl [options] inputfile > outputfile
\&  $ eperl [options] \-o outputfile \- < inputfile
\&  $ eperl [options] \-o outputfile inputfile
.Ve
.Sp
As you can see, ePerl can be used in any combination of \s-1STDIO\s0 and external
files. Additionally there are two interesting variants of using this mode.
First you can use ePerl in conjunction with the Unix \fIShebang\fR magic
technique to implicitly select it as the interpreter for your script similar
to the way you are used to with the plain Perl interpreter:
.Sp
.Vb 4
\&  #!/path/to/eperl [options]
\&  foo
\&  <: print "bar"; :>
\&  quux
.Ve
.Sp
However, many shells (such as tcsh) don't support dual-shebang \- in 
other words, you can't have a shebang path that points to an 
executable that also uses shebang.  Since ePerl is written in Perl, 
it is a shebang script as well.  The solution to this is simple \- move
the eperl script to eperl.pl, and then create a simple C wrapper to eperl:
.Sp
.Vb 1
\& main(int argc, char **argv) { execv("/path/to/eperl.pl",argv); }
.Ve
.Sp
Second, you can use ePerl in conjunction with the Bourne-Shell \fIHere
Document\fR technique from within you shell scripts:
.Sp
.Vb 8
\&  #!/bin/sh
\&  ...
\&  eperl [options] \- <<EOS
\&  foo
\&  <: print "quux"; :>
\&  quux
\&  EOS
\&  ...
.Ve
.Sp
The \fIParse::ePerl\fR\|(3) package method that comes with the C version of ePerl
is not yet supported in the Perl version of ePerl.
.IP "\fI\s-1CGI/1\s0.1 compliant interface mode\fR" 4
.IX Item "CGI/1.1 compliant interface mode"
This is the runtime mode where ePerl uses the \s-1CGI/1\s0.1 interface of a webserver
when used as a \fIServer-Side Scripting Language\fR on the Web. ePerl enters this
mode automatically when the \s-1CGI/1\s0.1 environment variable \f(CW\*(C`PATH_TRANSLATED\*(C'\fR is
set and its or the scripts filename does \fInot\fR begin with the \s-1NPH\s0 prefix
``\fInph\-\fR''.  In this runtime mode it prefixes the resulting data with
\&\s-1HTTP/1\s0.0 (default) or \s-1HTTP/1\s0.1 (if identified by the webserver) compliant
response header lines.
.Sp
ePerl also recognizes \s-1HTTP\s0 header lines at the beginning of the scripts
generated data, i.e. for instance you can generate your own \s-1HTTP\s0 headers like
.Sp
.Vb 5
\&   <? $url = "..";
\&      print "Location: $url\en";
\&      print "URI: $url\en\en"; !>
\&   <html>
\&   ...
.Ve
.Sp
But notice that while you can output arbitrary headers, most webservers
restrict the headers which are accepted via the \s-1CGI/1\s0.1 interface. Usually you
can provide only a few specific \s-1HTTP\s0 headers like \f(CW\*(C`Location\*(C'\fR or \f(CW\*(C`Status\*(C'\fR.
If you need more control you have to use the \s-1NPH\-CGI/1\s0.1 interface mode.
.Sp
ePerl does not currently support \fISetUID\fR switching since I haven't had
time to make sure that this can be done safely. If you know enough about
\&\fISetUID\fR and can implement this, I'd love to see a patch.  If you need
\&\fISetUID\fR switching, see the original ePerl.
.Sp
There are two commonly known ways of using this \s-1CGI/1\s0.1 interface mode on the
Web. First, you can use it to explicitly transform plain \s-1HTML\s0 files into
\&\s-1CGI/1\s0.1 scripts via the \fIShebang\fR technique (see above). For an Apache
webserver just put the following line as the first line of the file:
.Sp
.Vb 1
\&  #!/path/to/eperl \-mc
.Ve
.Sp
Then rename the script from \fIfile.html\fR to \fIfile.cgi\fR and set its execution
bit via
.Sp
.Vb 2
\&  $ mv file.html file.cgi
\&  $ chmod a+rx file.cgi
.Ve
.Sp
Now make sure that Apache accepts \fIfile.cgi\fR as a \s-1CGI\s0 program by enabling \s-1CGI\s0
support for the directory where \fIfile.cgi\fR resides. For this add the line
.Sp
.Vb 1
\&  Options +ExecCGI
.Ve
.Sp
to the \fI.htaccess\fR file in this directory. Finally make sure that Apache
really recognizes the extension \fI.cgi\fR. Perhaps you additionally have to add
the following line to your \fIhttpd.conf\fR file:
.Sp
.Vb 1
\&  AddHandler cgi\-script .cgi
.Ve
.Sp
Now you can use \fIfile.cgi\fR instead of \fIfile.html\fR and make advantage of the
achieved programming capability by bristling \fIfile.cgi\fR with your Perl
blocks (or the transformation into a \s-1CGI\s0 script would be useless).
.Sp
Alternatively (or even additionally) a webmaster can enable ePerl support in a
more seamless way by configuring ePerl as a real implicit server-side
scripting language. This is done by assigning a MIME-type to the various valid
ePerl file extensions and forcing all files with this MIME-type to be
internally processed via the ePerl interpreter. You can accomplish this for
Apache by adding the following to your \fIhttpd.conf\fR file
.Sp
.Vb 3
\&  AddType      application/x\-httpd\-eperl  .phtml .eperl .epl
\&  Action       application/x\-httpd\-eperl  /internal/cgi/eperl
\&  ScriptAlias  /internal/cgi              /path/to/apache/cgi\-bin
.Ve
.Sp
and creating a copy of the \fIeperl\fR program in your CGI\-directory:
.Sp
.Vb 1
\&  $ cp \-p /path/to/eperl /path/to/apache/cgi\-bin/eperl
.Ve
.Sp
Now all files with the extensions \fI.phtml\fR, \fI.eperl\fR and \fI.epl\fR are
automatically processed by the ePerl interpreter. There is no need for a
\&\fIShebang\fR line or any locally enabled \s-1CGI\s0 mode.
.Sp
One final hint: When you want to test your scripts offline, just run them with
forced \s-1CGI/1\s0.1 mode from your shell. But make sure you prepare all environment
variables your script depends on, e.g. \f(CW\*(C`QUERY_STRING\*(C'\fR or \f(CW\*(C`PATH_INFO\*(C'\fR.
.Sp
.Vb 2
\&  $ export QUERY_STRING="key1=value1&key2=value2"
\&  $ eperl \-mc file.phtml
.Ve
.IP "\fI\s-1NPH\-CGI/1\s0.1 compliant interface mode\fR" 4
.IX Item "NPH-CGI/1.1 compliant interface mode"
This runtime mode is a special variant of the \s-1CGI/1\s0.1 interface mode, because
most webservers (e.g. Apache) provide it for special purposes.   It is known
as \fINon-Parsed-Header\fR (\s-1NPH\s0) \s-1CGI/1\s0.1 mode and is usually used by the
webserver when the filename of the \s-1CGI\s0 program is prefixed with ``\f(CW\*(C`nph\-\*(C'\fR''.
In this mode the webserver does no processing on the \s-1HTTP\s0 response headers and
no buffering of the resulting data, i.e. the \s-1CGI\s0 program actually has to
provide a complete \s-1HTTP\s0 response itself. The advantage is that the program can
generate arbitrary \s-1HTTP\s0 headers or MIME-encoded multi-block messages.
.Sp
So, 
above we have renamed the file to \fIfile.cgi\fR which restricted us a little
bit. When we alternatively rename \fIfile.html\fR to \fInph\-file.cgi\fR and force
the \s-1NPH\-CGI/1\s0.1 interface mode via option \fB\-mn\fR then this file becomes a
\&\s-1NPH\-CGI/1\s0.1 compliant program under Apache and other webservers. Now our
script can provide its own \s-1HTTP\s0 response (it need not, because when absent
ePerl provides a default one for it).
.Sp
.Vb 6
\&  #!/path/to/bin/eperl \-mn
\&  <? print "HTTP/1.0 200 Ok\en";
\&     print "X\-MyHeader: Foo Bar Quux\en";
\&     print "Content\-type: text/html\en\en";
\&  <html>
\&  ...
.Ve
.Sp
As you expect this can be also used with the implicit Server-Side Scripting
Language technique. Put  
.Sp
.Vb 3
\&  AddType      application/x\-httpd\-eperl  .phtml .eperl .epl
\&  Action       application/x\-httpd\-eperl  /internal/cgi/nph\-eperl
\&  ScriptAlias  /internal/cgi              /path/to/apache/cgi\-bin
.Ve
.Sp
into your \fIhttpd.conf\fR and run the command
.Sp
.Vb 1
\&  $ cp \-p /path/to/eperl /path/to/apache/cgi\-bin/nph\-eperl
.Ve
.Sp
from your shell. \fIThis is the preferred way of using ePerl as a Server-Side
Scripting Language, because it provides most flexibility\fR.
.Sh "ePerl Preprocessor"
.IX Subsection "ePerl Preprocessor"
ePerl provides an own preprocessor similar to \fI\s-1CPP\s0\fR in style which is either
enabled manually via option \fB\-P\fR or automatically when ePerl runs in
(\s-1NPH\-\s0)CGI mode.  The following directives are supported:
.ie n .IP """#include path""" 4
.el .IP "\f(CW#include path\fR" 4
.IX Item "#include path"
This directive is an include directive which can be used to include really any
stuff, but was actually designed to be used to include other ePerl source
files. The \fIpath\fR can be either a relative or absolute path for the local
filesystem or a fully qualified \s-1HTTP\s0 \s-1URL\s0.
.Sp
In case of the absolute path the file is directly accessed on the filesystem,
while the relative path is first searched in the current working directory and
then in all directories specified via option \fB\-I\fR. In the third case
(\s-1HTTP\s0 \s-1URL\s0) the file is retrieves via a \s-1HTTP/1\s0.0 request on the network. 
Here \s-1HTTP\s0 redirects (response codes 301 and 302) are supported, too.
.Sp
Notice: While ePerl strictly preserves the line numbers when translating the
bristled ePerl format to plain Perl format, the ePerl preprocessor can't do
this (because its a \fBpre\fRprocessor which expands) for this directive.  So,
whenever you use \f(CW\*(C`#include\*(C'\fR, remember that line numbers in error messages are
wrong.
.Sp
Also notice one important security aspect: Because you can include any stuff
as it is provided with this directive, use it only for stuff which is under
your direct control. Don't use this directive to include foreign data, at
least not from external webservers. For instance say you have a ePerl page
with \f(CW\*(C`#include http://www.foreigner.com/nice\-page.html\*(C'\fR and at the next
request of this page your filesystem is lost! Why? Because the foreigner
recognizes that you include his page and are using ePerl and just put a simple
``\f(CW\*(C`<?  system("rm \-rf /"); !>\*(C'\fR'' in his page. Think about it.
\&\fI\s-1NEVER\s0 \s-1USE\s0 #INCLUDE \s-1FOR\s0 \s-1ANY\s0 \s-1DATA\s0 \s-1WHICH\s0 \s-1IS\s0 \s-1NOT\s0 \s-1UNDER\s0 \s-1YOUR\s0 \s-1OWN\s0 \s-1CONTROL\s0\fR.
Instead always use \f(CW\*(C`#sinclude\*(C'\fR for such situations.
.ie n .IP """#sinclude path""" 4
.el .IP "\f(CW#sinclude path\fR" 4
.IX Item "#sinclude path"
This is the secure variant of \f(CW\*(C`#include\*(C'\fR where after reading the data from
\&\fIpath\fR all ePerl begin and end delimiters are removed, #include is converted
to #sinclude, and the #if directives are ignored. So risky ePerl blocks lose
their meaning and are converted to plain text. Always use this directive
when you want to include data which is not under your own control.
.ie n .IP """#if expr""\fR, \f(CW""#elsif expr""\fR, \f(CW""#else""\fR, \f(CW""#endif""" 4
.el .IP "\f(CW#if expr\fR, \f(CW#elsif expr\fR, \f(CW#else\fR, \f(CW#endif\fR" 4
.IX Item "#if expr, #elsif expr, #else, #endif"
These implement a CPP-style \f(CW\*(C`#if\-[#else\-]#endif\*(C'\fR construct, but with a Perl
semantic. While the other directives are real preprocessor commands which are
evaluated at the preprocessing step, this construct is actually just
transformed into a low-level ePerl construct, so it is \fBnot\fR actually
evaluated at the preprocessing step. It is just a handy shortcut for the
following (where \s-1BD\s0 is the currently used begin delimiter and \s-1ED\s0 the end
delimiter):
.Sp
.Vb 4
\&  ``#if expr''    \->  ``BD if (expr) { _ ED//''
\&  ``#elsif expr'' \->  ``BD } elsif (expr) { _ ED//''
\&  ``#else''       \->  ``BD } else { _ ED//''
\&  ``#endif''      \->  ``BD } _ ED//''
.Ve
.Sp
The advantage of this unusual aproach is that the if-condition really can be
any valid Perl expression which provides maximum flexibility. The disadvantage
is that you cannot use the if-construct to make real preprocessing decisions.
As you can see, the design goal was just to provide a shorthand for the more
complicated Perl constructs.
.ie n .IP """#c""" 4
.el .IP "\f(CW#c\fR" 4
.IX Item "#c"
This is the comment directive which just discards all data up to and including
the newline character. Use this one to comment out any stuff, even other
preprocessor directives.
.Sh "Provided Functionality"
.IX Subsection "Provided Functionality"
Up to know you've understand that ePerl provides a nice facility to embed Perl
code into any \s-1ASCII\s0 data. But now the typical question is: Which Perl code can
be put into these ePerl blocks and does ePerl provide any special
functionality inside these ePerl blocks?
.PP
The answers are: First, you can put really \fIany\fR Perl code into the 
ePerl blocks which are valid Perl. Second, ePerl does \fInot\fR provide 
any special functionality inside these ePerl blocks, because Perl is 
already sophisticated enough ;\-)
.PP
The implication of this is: Because you can use any valid Perl code you can
make use of all available Perl 5 modules, even those ones which use shared
objects. So, browse to the Comprehensive Perl Archive Network (\s-1CPAN\s0) via
http://www.perl.com/perl/CPAN and grab your favorite packages which can make
your life easier (both from within plain Perl scripts \fIand\fR ePerl scripts)
and just use the construct ``\f(CW\*(C`use name;\*(C'\fR'' in any ePerl block to use them
from within ePerl. 
.PP
When using ePerl as a Server-Side-Scripting-Language I really recommend you to
install at least the packages \fI\s-1CGI\s0.pm\fR (currently vers.  2.36),
\&\fIHTML-Stream\fR (1.40), \fIlibnet\fR (1.0505) and \fIlibwww-perl\fR (5.08).  When you
want to generate on-the-fly images as well, I recommend you to additionally
install at least \fI\s-1GD\s0\fR (1.14) and \fIImage-Size\fR (2.3). The ePerl interpreter
in conjunction with these really sophisticated Perl 5 modules will provide you
with maximum flexibility and functionality. In other words: \fIMake use of
maximum Software Leverage in the hackers world of Perl as great as possible\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-d\fR \fIname\fR=\fIvalue\fR, \fB\-\-define\fR=\fIname\fR=\fIvalue\fR" 4
.IX Item "-d name=value, --define=name=value"
Sets a Perl variable in the package \f(CW\*(C`main\*(C'\fR which can be referenced
via \f(CW$name\fR or more explicitly via \f(CW$main::name\fR. The command
.Sp
.Vb 1
\&  eperl \-d name=value ..
.Ve
.Sp
is actually equivalent to having
.Sp
.Vb 1
\&  <? $name = value; !>
.Ve
.Sp
at the beginning of \fIinputfile\fR. This option can occur more than once.
.IP "\fB\-D\fR \fIname\fR=\fIvalue\fR, \fB\-\-setenv\fR=\fIname\fR=\fIvalue\fR" 4
.IX Item "-D name=value, --setenv=name=value"
Sets a environment variable which can be referenced via \f(CW$ENV{'variable'}\fR
inside the Perl blocks. The command
.Sp
.Vb 1
\&  eperl \-D name=value ..
.Ve
.Sp
is actually equivalent to 
.Sp
.Vb 1
\&  export name=value; eperl ...
.Ve
.Sp
but the advantage of this option is that it doesn't manipulate the callers
environment. This option can occur more than once.
.IP "\fB\-B\fR \fIbegin_delimiter\fR, \fB\-\-block\-begin\fR=\fIbegin_delimiter\fR" 4
.IX Item "-B begin_delimiter, --block-begin=begin_delimiter"
Sets the Perl block begin delimiter string. Use this in conjunction with \f(CW\*(C`\-E\*(C'\fR
to set different delimiters when using ePerl as an offline \s-1HTML\s0
creation-language while still using it as an online \s-1HTML\s0 scripting\-language.
Default delimiters are \f(CW\*(C`<?\*(C'\fR and \f(CW\*(C`!>\*(C'\fR for \s-1CGI\s0 modes and \f(CW\*(C`<:\*(C'\fR and
\&\f(CW\*(C`:>\*(C'\fR for stand-alone Unix filtering mode.
.Sp
There are a lot of possible variations you could choose: "\f(CW\*(C`<:\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`:>\*(C'\fR\*(L" (the default ePerl stand-alone filtering mode delimiters),
\&\*(R"\f(CW\*(C`<?\*(C'\fR\*(L" and \*(R"\f(CW\*(C`!>\*(C'\fR\*(L" (the default ePerl \s-1CGI\s0 interface mode delimiters),
\&\*(R"\f(CW\*(C`<script language='ePerl'>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`</script>\*(C'\fR\*(L" (standard
\&\s-1HTML\s0 scripting language style), \*(R"\f(CW\*(C`<script type="text/eperl">\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`</script>\*(C'\fR\*(L" (forthcoming \s-1HTML3\s0.2+ aka Cougar style),
\&\*(R"\f(CW\*(C`<eperl>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`</eperl>\*(C'\fR\*(L" (HTML\-like style),
\&\*(R"\f(CW\*(C`<!\-\-#eperl code='\*(C'\fR\*(L" and \*(R"\f(CW\*(C`' \-\->\*(C'\fR\*(L" (NeoScript and \s-1SSI\s0 style) or
even \*(R"\f(CW\*(C`<?\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>\*(C'\fR" (\s-1PHP/FI\s0 style; but this no longer recommended
because it can lead to parsing problems. Should be used only for backward
compatibility to old ePerl versions 1.x).
.Sp
The begin and end delimiters are searched case\-insensitive.
.IP "\fB\-E\fR \fIend_delimiter\fR, \fB\-\-block\-end\fR=\fIend_delimiter\fR" 4
.IX Item "-E end_delimiter, --block-end=end_delimiter"
Sets the Perl block end delimiter string. See also option \fB\-B\fR.
.IP "\fB\-i\fR, \fB\-\-ignorecase\fR" 4
.IX Item "-i, --ignorecase"
Forces the begin and end delimiters to be searched case\-insensitive.  Use this
when you are using delimiters like
``\f(CW\*(C`<ePerl>\*(C'\fR...\f(CW\*(C`</ePerl>\*(C'\fR'' or other more textual ones.
.IP "\fB\-m\fR \fImode\fR, \fB\-\-mode\fR=\fImode\fR" 4
.IX Item "-m mode, --mode=mode"
This forces ePerl to act in a specific runtime mode.  See above for a detailed
description of the three possible modes: Stand-alone filter (\fImode\fR=\f(CW\*(C`f\*(C'\fR,
i.e. option \fB\-mf\fR), \s-1CGI/1\s0.1 interface mode (\fImode\fR=\f(CW\*(C`c\*(C'\fR, i.e. option \fB\-mc\fR)
or the \s-1NPH\-CGI/1\s0.1 interface mode (\fImode\fR=\f(CW\*(C`n\*(C'\fR, i.e. option \fB\-mn\fR).
.IP "\fB\-o\fR \fIoutputfile\fR, \fB\-\-outputfile\fR=\fIoutputfile\fR" 4
.IX Item "-o outputfile, --outputfile=outputfile"
Forces the output to be written to \fIoutputfile\fR instead of \fI\s-1STDOUT\s0\fR. Use
this option when using ePerl as a filter. The outputfile ``\fI\-\fR'' sets \fI\s-1STDOUT\s0\fR
as the output handle explicitly. Notice that this file is relative to the
source file directory when the runtime mode is forced to \s-1CGI\s0 or \s-1NPH\-CGI\s0.
.IP "\fB\-k\fR, \fB\-\-keepcwd\fR" 4
.IX Item "-k, --keepcwd"
Forces ePerl to keep the current working directory from where it was started.
Per default ePerl will change to the directory where the file to be executed
stays. This option is useful if you use ePerl as an offline filter on
a temporary file.
.IP "\fB\-x\fR, \fB\-\-debug\fR" 4
.IX Item "-x, --debug"
This sets debug mode where ePerl outputs the internally created Perl script to
\&\s-1STDOUT\s0 before executing it. Only for debugging problems with the inputfile
conversion.
.IP "\fB\-X\fR, \fB\-\-heavy_debug\fR" 4
.IX Item "-X, --heavy_debug"
This sets heavy debug mode.  Only the internally created Perl script is
output, it is not executed.
.IP "\fB\-I\fR \fIdirectory\fR, \fB\-\-includedir\fR=\fIdirectory\fR" 4
.IX Item "-I directory, --includedir=directory"
Specify a directory which is both used for \f(CW\*(C`#include\*(C'\fR and \f(CW\*(C`#sinclude\*(C'\fR
directives of the ePerl preprocessor and added to \f(CW@INC\fR under runtime.  This
option can occur more than once.
.IP "\fB\-P\fR, \fB\-\-preprocess\fR" 4
.IX Item "-P, --preprocess"
Manually enables the special ePerl Preprocessor (see above). This option is
enabled for all \s-1CGI\s0 modes automatically.
.IP "\fB\-C\fR, \fB\-\-check\fR" 4
.IX Item "-C, --check"
This enables the \s-1HTML\s0 entity conversion for ePerl blocks. This option is
automatically forced in \s-1CGI\s0 modes. 
.Sp
The solved problem here is the following: When you use ePerl as a
Server-Side-Scripting-Language for \s-1HTML\s0 pages and you edit your ePerl source
files via a \s-1HTML\s0 editor, the chance is high that your editor translates some
entered characters to \s-1HTML\s0 entities, for instance ``\f(CW\*(C`<\*(C'\fR'' to ``\f(CW\*(C`&lt;\*(C'\fR''.
This leads to invalid Perl code inside ePerl blocks, because the \s-1HTML\s0 editor
has no knowledge about ePerl blocks. Using this option the ePerl parser
automatically converts all entities found inside ePerl blocks back to plain
characters, so the Perl interpreter again receives valid code blocks.
.IP "\fB\-L\fR, \fB\-\-line\-continue\fR" 4
.IX Item "-L, --line-continue"
This enables the line continuation character ``\f(CW\*(C`\e\*(C'\fR'' (backslash) outside
ePerl blocks. With this option you can spread oneline-data over more lines.
But use with care: This option changes your data (outside ePerl blocks).
Usually ePerl really pass through all surrounding data as raw data. With this
option the newlines become new semantics.
.IP "\fB\-T\fR, \fB\-\-tainting\fR" 4
.IX Item "-T, --tainting"
This enabled Perl's \fITainting mode\fR where the Perl interpreter takes special
precautions called taint checks to prevent both obvious and subtle traps.  See
\&\fIperlsec\fR\|(1) for more details.
.IP "\fB\-w\fR, \fB\-\-warnings\fR" 4
.IX Item "-w, --warnings"
This enables Warnings where the Perl interpreter produces some lovely
diagnostics. See \fIperldiag\fR\|(1) for more details.
.IP "\fB\-c\fR, \fB\-\-check\fR" 4
.IX Item "-c, --check"
This runs a pure syntax check which is similar to ``\f(CW\*(C`perl \-c\*(C'\fR''.
.IP "\fB\-r\fR, \fB\-\-readme\fR" 4
.IX Item "-r, --readme"
This prints the internal ePerl \s-1README\s0 file to the console.
.IP "\fB\-l\fR, \fB\-\-license\fR" 4
.IX Item "-l, --license"
This prints the internal ePerl \s-1LICENSE\s0 file to the console.
.IP "\fB\-v\fR, \fB\-\-version\fR" 4
.IX Item "-v, --version"
This prints ePerl version information to the console.
.IP "\fB\-V\fR, \fB\-\-ingredients\fR" 4
.IX Item "-V, --ingredients"
Same as option \fB\-v\fR (supported for ePerl compatibility)
.IP "\fB\-e\fR, \fB\-\-execute\fR" 4
.IX Item "-e, --execute"
Specify some code to execute at the top of the script
.IP "\fB\-s\fR, \fB\-\-strict\fR" 4
.IX Item "-s, --strict"
Strict mode.  This does a bunch of things a little slower and more
complicated, in order to get behavior that matches the C version of ePerl.
Use this only if you have an old ePerl script and it isn't working exactly
the way you want it to under this ePerl.  Specifically, it:
.Sp
.Vb 4
\&  1)  Inits environment variables even in filter mode
\&  2)  Uses an open3 set of file descriptors to talk to perl,
\&      so we can separately grab STDOUT and STDERR and consider
\&      a write to STDERR to be an error code.
.Ve
.Sp
Non-strict mode allows some new features:
.Sp
.Vb 3
\&  1)  ePerl input can specify fake file/line info for errors
\&      with [#change file: <line> "filename"] directive
\&  2)  Comments that end with // will disappear completely
.Ve
.IP "\fB\-t\fR, \fB\-\-tmpfile\fR" 4
.IX Item "-t, --tmpfile"
Use a tmpfile for the script instead of piping it directly to perl.  
This allows you to read \s-1STDIN\s0 from your eperl script, which CGIs that 
use \s-1POST\s0 will need to do \- though this is less safe since someone 
might be able to alter your script before you run it.  You can change 
the \f(CW$TMPDIR\fR in eperl to a non globally writable directory to protect 
against this.
.IP "\fB\-1\fR, \fB\-\-eval\fR" 4
.IX Item "-1, --eval"
Use an eval instead of forking a new perl process (single process mode).
This is useful for systems that have trouble with forks, such as Windows
(where \-\-eval is the default behavior).  Requires \fIIO::String\fR module.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.Sh "Used Variables"
.IX Subsection "Used Variables"
.ie n .IP """PATH_TRANSLATED""" 4
.el .IP "\f(CWPATH_TRANSLATED\fR" 4
.IX Item "PATH_TRANSLATED"
This \s-1CGI/1\s0.1 variable is used to determine the source file when ePerl operates
as a \s-1NPH\-CGI/1\s0.1 program under the environment of a webserver.
.Sh "Provided Variables"
.IX Subsection "Provided Variables"
.ie n .IP """SCRIPT_SRC_PATH""" 4
.el .IP "\f(CWSCRIPT_SRC_PATH\fR" 4
.IX Item "SCRIPT_SRC_PATH"
The absolute pathname of the script. Use this when you want to
directly access the script from within itself, for instance to do
\&\f(CW\*(C`stat()\*(C'\fR and other calls.
.ie n .IP """SCRIPT_SRC_PATH_DIR""" 4
.el .IP "\f(CWSCRIPT_SRC_PATH_DIR\fR" 4
.IX Item "SCRIPT_SRC_PATH_DIR"
The directory part of \f(CW\*(C`SCRIPT_SRC_PATH\*(C'\fR. Use this one when you want to
directly access other files residing in the same directory as the script, for
instance to read config files, etc.
.ie n .IP """SCRIPT_SRC_PATH_FILE""" 4
.el .IP "\f(CWSCRIPT_SRC_PATH_FILE\fR" 4
.IX Item "SCRIPT_SRC_PATH_FILE"
The filename part of \f(CW\*(C`SCRIPT_SRC_PATH\*(C'\fR. Use this one when you need the name
of the script, for instance for relative self-references through URLs.
.ie n .IP """SCRIPT_SRC_URL""" 4
.el .IP "\f(CWSCRIPT_SRC_URL\fR" 4
.IX Item "SCRIPT_SRC_URL"
The fully-qualified \s-1URL\s0 of the script. Use this when you need a \s-1URL\s0 for
self\-reference.
.ie n .IP """SCRIPT_SRC_URL_DIR""" 4
.el .IP "\f(CWSCRIPT_SRC_URL_DIR\fR" 4
.IX Item "SCRIPT_SRC_URL_DIR"
The directory part of \f(CW\*(C`SCRIPT_SRC_URL\*(C'\fR. Use this one when you want to
directly access other files residing in the same directory as the script via
the Web, for instance to reference images, etc.
.ie n .IP """SCRIPT_SRC_URL_FILE""" 4
.el .IP "\f(CWSCRIPT_SRC_URL_FILE\fR" 4
.IX Item "SCRIPT_SRC_URL_FILE"
The filename part of \f(CW\*(C`SCRIPT_SRC_URL\*(C'\fR. Use this one when you need the name of
the script, for instance for relative self-references through URLs.  Actually
the same as \f(CW\*(C`SCRIPT_SRC_PATH_FILE\*(C'\fR, but provided for consistency. 
.ie n .IP """SCRIPT_SRC_SIZE""" 4
.el .IP "\f(CWSCRIPT_SRC_SIZE\fR" 4
.IX Item "SCRIPT_SRC_SIZE"
The filesize of the script, in bytes.
.ie n .IP """SCRIPT_SRC_MODIFIED""" 4
.el .IP "\f(CWSCRIPT_SRC_MODIFIED\fR" 4
.IX Item "SCRIPT_SRC_MODIFIED"
The last modification time of the script, in seconds since 0 hours, 0 minutes,
0 seconds, January 1, 1970, Coordinated Universal Time.
.ie n .IP """SCRIPT_SRC_MODIFIED_CTIME""" 4
.el .IP "\f(CWSCRIPT_SRC_MODIFIED_CTIME\fR" 4
.IX Item "SCRIPT_SRC_MODIFIED_CTIME"
The last modification time of the script, in \fIctime\fR\|(3) format (``\s-1WDAY\s0 \s-1MMM\s0 \s-1DD\s0
\&\s-1HH:MM:SS\s0 YYYY\en'').
.ie n .IP """SCRIPT_SRC_MODIFIED_ISOTIME""" 4
.el .IP "\f(CWSCRIPT_SRC_MODIFIED_ISOTIME\fR" 4
.IX Item "SCRIPT_SRC_MODIFIED_ISOTIME"
The last modification time of the script, in \s-1ISO\s0 format (``\s-1DD\-MM\-YYYY\s0
\&\s-1HH:MM\s0'').
.ie n .IP """SCRIPT_SRC_OWNER""" 4
.el .IP "\f(CWSCRIPT_SRC_OWNER\fR" 4
.IX Item "SCRIPT_SRC_OWNER"
The username of the script owner.  (Not available on Windows)
.ie n .IP """VERSION_INTERPRETER""" 4
.el .IP "\f(CWVERSION_INTERPRETER\fR" 4
.IX Item "VERSION_INTERPRETER"
The ePerl identification string.
.ie n .IP """VERSION_LANGUAGE""" 4
.el .IP "\f(CWVERSION_LANGUAGE\fR" 4
.IX Item "VERSION_LANGUAGE"
The identification string of the used Perl interpreter library.
.Sh "Provided Built-In Images"
.IX Subsection "Provided Built-In Images"
The ePerl built-in images are not supported because of size/copyright issues.
If enough people ask for this capability, I'll come up with a replacement.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  David Ljung Madison
\&  eperl \-at\- MarginalHacks.com
\&  http://MarginalHacks.com
.Ve
.PP
.Vb 4
\&  Author of original ePerl:
\&    Ralf S. Engelschall
\&    rse@engelschall.com
\&    www.engelschall.com
.Ve
.SH "SEEALSO"
.IX Header "SEEALSO"
\&\fIPerl\fR\|(1)
.PP
Web\-References:
.PP
.Vb 4
\&  Perl:           perl(1),  http://www.perl.com/
\&  ePerl:          eperl(1), http://MarginalHacks.com/Hacks/ePerl
\&  original ePerl: eperl(1), http://www.engelschall.com/sw/eperl/
\&  Apache:         httpd(8), http://www.apache.org/
.Ve
